from __future__ import annotations

from typing import TYPE_CHECKING, Any, Literal

from pydantic_graph.v2.decision import Decision
from pydantic_graph.v2.id_types import NodeId
from pydantic_graph.v2.join import Join
from pydantic_graph.v2.node import EndNode, Spread, StartNode
from pydantic_graph.v2.step import Step

if TYPE_CHECKING:
    from pydantic_graph.v2.graph import Graph

__all__ = (
    'DEFAULT_HIGHLIGHT_CSS',
    'generate_code',
    'StateDiagramDirection',
)
DEFAULT_HIGHLIGHT_CSS = 'fill:#fdff32'
"""The default CSS to use for highlighting nodes."""


StateDiagramDirection = Literal['TB', 'LR', 'RL', 'BT']
"""Used to specify the direction of the state diagram generated by mermaid.

- `'TB'`: Top to bottom, this is the default for mermaid charts.
- `'LR'`: Left to right
- `'RL'`: Right to left
- `'BT'`: Bottom to top
"""


def generate_code(
    graph: Graph[Any, Any, Any, Any],
    /,
    *,
    # highlight_css: str = DEFAULT_HIGHLIGHT_CSS,
    edge_labels: bool = True,
    title: str | None = None,
    direction: StateDiagramDirection | None = None,
) -> str:
    """Generate [Mermaid state diagram](https://mermaid.js.org/syntax/stateDiagram.html) code for a graph.

    Args:
        graph: The graph to generate the image for.
        start_node: Identifiers of nodes that start the graph.
        highlighted_nodes: Identifiers of nodes to highlight.
        highlight_css: CSS to use for highlighting nodes.
        title: The title of the diagram.
        edge_labels: Whether to include edge labels in the diagram.
        notes: Whether to include notes in the diagram.
        direction: The direction of flow.


    Returns:
        The Mermaid code for the graph.
    """
    # graph.start_edges
    # start_node_ids = set(_node_ids(start_node or ()))
    # for node_id in start_node_ids:
    #     if node_id not in graph.node_defs:
    #         raise LookupError(f'Start node "{node_id}" is not in the graph.')

    lines: list[str] = []
    if title:
        lines = ['---', f'title: {title}', '---']
    lines.append('stateDiagram-v2')
    if direction is not None:
        lines.append(f'  direction {direction}')

    broadcast_forks = dict[NodeId, NodeId]()
    for node in graph.nodes.values():
        # List all nodes in order they were created
        node_lines: list[str] = []
        if isinstance(node, (StartNode, EndNode)):
            pass
        elif isinstance(node, Step):
            line = f'  {node.id}'
            if node.label:
                line += f': {node.label}'
            node_lines.append(line)
        elif isinstance(node, Join):
            node_lines = [f'  state {node.id} <<join>>']
        elif isinstance(node, Spread):
            node_lines = [f'  state {node.id} <<fork>>']
        elif isinstance(node, Decision):
            node_lines = [f'  state {node.id} <<choice>>']
            if node.note:
                node_lines.append(f'  note right of {node.id}\n    {node.note}\n  end note')
        is_broadcast_fork = len(graph.edges_by_source.get(node.id, [])) > 1
        if is_broadcast_fork:
            broadcast_forks[node.id] = NodeId(node.id + '_fork')  # TODO: Need to guarantee this is unique
            node_lines.append(f'  state {broadcast_forks[node.id]} <<fork>>')
        lines.extend(node_lines)

    lines.append('')

    for source_id, node in graph.nodes.items():
        render_source_id = source_id

        if source_id == StartNode.start.id:
            render_source_id = '[*]'  # Mermaid uses [*] to denote the start state

        if source_id in broadcast_forks:
            lines.append(f'  {render_source_id} --> {broadcast_forks[source_id]}')
            render_source_id = broadcast_forks[source_id]

        for edge in graph.edges_by_source[source_id]:
            destination_id = edge.destination_id
            if destination_id == EndNode.end.id:
                destination_id = '[*]'  # Mermaid uses [*] to denote the end state
            lines.append(f'  {render_source_id} --> {destination_id}')

            # TODO: Support node notes/highlighting
            # TODO: Support edge labels (probably derive from the transform, etc.):
            # if edge.label:
            #     lines.append(f'  {source_id} --> {edge.destination_id}: {edge.label}')

        if isinstance(node, Decision):
            for branch in node.branches:
                # Render the decision branches
                destination_id = branch.route_to.id
                if destination_id == EndNode.end.id:
                    destination_id = '[*]'  # Mermaid uses [*] to denote the end state
                line = f'  {render_source_id} --> {destination_id}'
                if edge_labels:
                    line += f': {branch.label}'
                lines.append(line)
                # TODO: Support node notes/highlighting

    return '\n'.join(lines)
